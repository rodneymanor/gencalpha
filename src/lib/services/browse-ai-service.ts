\n/**\n * Browse AI Service for fetching personalized video recommendations\n * Based on user's specific interests from onboarding workflow\n */\n\nexport interface BrowseAIVideoResult {\n  url: string;\n  title?: string;\n  description?: string;\n  thumbnail?: string;\n  author?: string;\n  platform?: string;\n  metrics?: {\n    views?: number;\n    likes?: number;\n    shares?: number;\n  };\n}\n\nexport interface BrowseAIResponse {\n  success: boolean;\n  data?: BrowseAIVideoResult[];\n  error?: string;\n  taskId?: string;\n}\n\ninterface RobotConfig {\n  robotId: string;\n  searchTerm: string;\n  additionalParams?: Record<string, any>;\n}\n\nexport class BrowseAIService {\n  private static readonly API_KEY = \"9ee4ab75-87bc-4324-a08e-72bc069c4697:06f085de-7569-435d-ae05-da6a0bba1ba5\";\n  private static readonly BASE_URL = \"https://api.browse.ai/v2\";\n\n  /**\n   * Trigger Browse AI robot to fetch videos based on specific interest\n   */\n  static async fetchVideosForInterest(specificInterest: string, limit: number = 10): Promise<BrowseAIResponse> {\n    const requestId = Math.random().toString(36).substring(7);\n    console.log(`ü§ñ [${requestId}] Starting Browse AI video fetch for interest: ${specificInterest}`);\n\n    try {\n      // Map specific interests to robot IDs and search parameters\n      const robotConfig = this.getRobotConfigForInterest(specificInterest);\n      if (!robotConfig) {\n        console.error(`‚ùå [${requestId}] No robot configuration found for interest: ${specificInterest}`);\n        return {\n          success: false,\n          error: `No robot configuration found for interest: ${specificInterest}`\n        };\n      }\n\n      console.log(`üîß [${requestId}] Using robot: ${robotConfig.robotId}, search: ${robotConfig.searchTerm}`);\n\n      // Step 1: Trigger the Browse AI robot\n      const taskResponse = await this.triggerRobot(robotConfig.robotId, {\n        keyword: robotConfig.searchTerm,\n        limit: limit,\n        ...robotConfig.additionalParams\n      });\n\n      if (!taskResponse.success || !taskResponse.taskId) {\n        console.error(`‚ùå [${requestId}] Failed to trigger robot:`, taskResponse.error);\n        return taskResponse;\n      }\n\n      console.log(`‚úÖ [${requestId}] Robot triggered successfully, task ID: ${taskResponse.taskId}`);\n\n      // Step 2: Poll for results\n      const results = await this.pollForResults(taskResponse.taskId, requestId);\n      \n      if (!results.success) {\n        console.error(`‚ùå [${requestId}] Failed to get results:`, results.error);\n        return results;\n      }\n\n      console.log(`‚úÖ [${requestId}] Successfully fetched ${results.data?.length || 0} videos`);\n      return results;\n\n    } catch (error) {\n      console.error(`‚ùå [${requestId}] Browse AI service error:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error occurred\"\n      };\n    }\n  }\n\n  /**\n   * Trigger Browse AI robot with input parameters\n   */\n  private static async triggerRobot(robotId: string, inputParameters: Record<string, any>): Promise<BrowseAIResponse> {\n    try {\n      const response = await fetch(`${this.BASE_URL}/robots/${robotId}/tasks`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.API_KEY}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ inputParameters })\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Browse AI API error: ${response.status} ${errorText}`);\n      }\n\n      const data = await response.json();\n      return {\n        success: true,\n        taskId: data.result?.id\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Failed to trigger robot\"\n      };\n    }\n  }\n\n  /**\n   * Poll for task results with timeout\n   */\n  private static async pollForResults(taskId: string, requestId: string, maxAttempts: number = 20): Promise<BrowseAIResponse> {\n    console.log(`‚è≥ [${requestId}] Polling for results, task: ${taskId}`);\n\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        console.log(`üîÑ [${requestId}] Polling attempt ${attempt}/${maxAttempts}`);\n\n        const response = await fetch(`${this.BASE_URL}/tasks/${taskId}`, {\n          headers: {\n            'Authorization': `Bearer ${this.API_KEY}`\n          }\n        });\n\n        if (!response.ok) {\n          throw new Error(`Polling failed: ${response.status}`);\n        }\n\n        const data = await response.json();\n        const status = data.result?.status;\n\n        console.log(`üìä [${requestId}] Task status: ${status}`);\n\n        if (status === 'successful') {\n          // Extract video data from the response\n          const videos = this.extractVideoData(data.result?.capturedData || []);\n          console.log(`‚úÖ [${requestId}] Task completed successfully, extracted ${videos.length} videos`);\n          \n          return {\n            success: true,\n            data: videos\n          };\n        } else if (status === 'failed') {\n          console.error(`‚ùå [${requestId}] Task failed:`, data.result?.error);\n          return {\n            success: false,\n            error: data.result?.error || \"Task failed\"\n          };\n        }\n\n        // Still processing, wait before next attempt\n        if (attempt < maxAttempts) {\n          console.log(`‚è≥ [${requestId}] Still processing, waiting 30 seconds...`);\n          await new Promise(resolve => setTimeout(resolve, 30000)); // 30 second delay\n        }\n\n      } catch (error) {\n        console.error(`‚ùå [${requestId}] Polling error on attempt ${attempt}:`, error);\n        \n        if (attempt < maxAttempts) {\n          await new Promise(resolve => setTimeout(resolve, 10000)); // 10 second delay on error\n        }\n      }\n    }\n\n    console.error(`‚ùå [${requestId}] Polling timeout after ${maxAttempts} attempts`);\n    return {\n      success: false,\n      error: \"Polling timeout - task took too long to complete\"\n    };\n  }\n\n  /**\n   * Extract video data from Browse AI captured data\n   */\n  private static extractVideoData(capturedData: any[]): BrowseAIVideoResult[] {\n    if (!Array.isArray(capturedData)) {\n      console.warn(\"‚ö†Ô∏è Captured data is not an array:\", capturedData);\n      return [];\n    }\n\n    return capturedData.map((item: any) => {\n      // Handle different possible data structures from Browse AI\n      const video: BrowseAIVideoResult = {\n        url: item.url || item.link || item.videoUrl || '',\n        title: item.title || item.name || '',\n        description: item.description || item.caption || '',\n        thumbnail: item.thumbnail || item.image || item.thumbnailUrl || '',\n        author: item.author || item.creator || item.username || '',\n        platform: this.detectPlatform(item.url || item.link || ''),\n        metrics: {\n          views: this.parseNumber(item.views || item.viewCount),\n          likes: this.parseNumber(item.likes || item.likeCount),\n          shares: this.parseNumber(item.shares || item.shareCount)\n        }\n      };\n\n      return video;\n    }).filter(video => video.url); // Only return videos with valid URLs\n  }\n\n  /**\n   * Detect platform from URL\n   */\n  private static detectPlatform(url: string): string {\n    if (url.includes('tiktok.com')) return 'tiktok';\n    if (url.includes('instagram.com')) return 'instagram';\n    if (url.includes('youtu